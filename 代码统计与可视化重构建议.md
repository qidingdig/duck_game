# 代码统计与可视化重构建议

## 一、当前架构分析

### 1.1 代码统计模块
- **`services/code_counter.py`**: 基础代码统计服务（278行）
- **`services/advanced_code_counter.py`**: 增强版代码统计服务（785行）
- **`ui/code_statistics.py`**: UI层，包含配置、统计执行、结果保存（853行）

### 1.2 数据可视化模块
- **`ui/chart_types.py`**: 图表类型抽象和实现（策略模式）
- **`ui/chart_layout.py`**: 布局策略抽象和实现（策略模式）
- **`ui/chart_data_extractor.py`**: 数据提取器
- **`ui/chart_renderer.py`**: 图表渲染器

## 二、主要问题

### 2.1 代码重复（DRY原则违反）

**问题**：
- `CodeCounter` 和 `AdvancedCodeCounter` 有大量重复代码：
  - `FileStat`、`Summary` 数据类定义重复
  - `is_binary()`、`detect_encoding()`、`iter_files()`、`classify_line()`、`count_file()` 等方法完全重复
  - 注释符配置、文件扩展名映射等配置重复

**影响**：
- 维护成本高：修改一处需要同步修改另一处
- 容易产生不一致：两个类可能逐渐分化
- 违反DRY（Don't Repeat Yourself）原则

### 2.2 职责不清（单一职责原则违反）

**问题**：
- `CodeStatisticsUI` 类承担了过多职责：
  1. UI配置窗口创建和管理（~350行）
  2. 统计执行逻辑协调（~150行）
  3. 结果格式化（~100行）
  4. 文件保存（CSV、JSON、XLSX，~250行）
  5. 图表显示协调（~10行）

**影响**：
- 类过大（853行），难以理解和维护
- 违反单一职责原则（SRP）
- 难以单独测试各个功能
- 扩展新功能需要修改大文件

### 2.3 耦合度高（依赖倒置原则违反）

**问题**：
- `CodeStatisticsUI` 直接依赖具体实现 `AdvancedCodeCounter`，没有抽象接口
- UI层直接处理业务逻辑（文件保存、数据格式化）
- 保存格式硬编码在UI类中

**影响**：
- 难以替换不同的统计实现
- 难以单独测试业务逻辑
- 违反依赖倒置原则（DIP）

### 2.4 扩展性不足（开闭原则部分违反）

**问题**：
- 文件保存逻辑硬编码在 `CodeStatisticsUI._save_results()` 中
- 添加新保存格式需要修改UI类
- 统计报告格式固定，难以自定义

**影响**：
- 违反开闭原则（OCP）：对扩展开放，对修改关闭
- 添加新功能需要修改现有代码

### 2.5 数据模型不一致

**问题**：
- `code_counter.py` 使用普通类（`class FileStat`）
- `advanced_code_counter.py` 使用 `@dataclass`
- 两个模块的数据结构不完全一致

**影响**：
- 代码风格不统一
- 可能导致集成问题

## 三、重构建议

### 3.1 消除代码重复

#### 方案：提取公共基类或组合

**建议**：使用组合模式，提取公共功能到独立类

```python
# services/code_counter_base.py
class CodeCounterBase:
    """代码统计基础类，包含公共功能"""
    def __init__(self):
        self.single_line_comments = {...}
        self.multi_line_comments = {...}
        # ... 公共配置
    
    def is_binary(self, path: str) -> bool:
        """检查文件是否为二进制文件"""
        ...
    
    def detect_encoding(self, path: str) -> str:
        """检测文件编码"""
        ...
    
    def iter_files(self, root: str, include: List[str], exclude: List[str]):
        """遍历文件"""
        ...
    
    def classify_line(self, line: str, ext: str, in_block: Optional[Tuple]) -> Tuple:
        """分类代码行"""
        ...
    
    def count_file(self, path: str) -> Optional[FileStat]:
        """统计单个文件"""
        ...

# services/code_counter.py
class CodeCounter(CodeCounterBase):
    """基础代码统计服务"""
    def count_code_lines(self, path: str, ...) -> str:
        """统计代码行数"""
        ...

# services/advanced_code_counter.py
class AdvancedCodeCounter(CodeCounterBase):
    """增强代码统计服务"""
    def count_code_by_language(self, path: str, ...) -> Dict:
        """按语言统计代码量"""
        ...
    
    def analyze_python_functions(self, path: str) -> List[FunctionStat]:
        """分析Python函数"""
        ...
    
    def analyze_c_functions(self, path: str) -> List[FunctionStat]:
        """分析C/C++函数"""
        ...
```

**优点**：
- 消除重复代码
- 公共功能集中管理
- 易于维护和扩展

### 3.2 拆分职责

#### 方案：按职责拆分 `CodeStatisticsUI`

**建议**：拆分为多个类

```python
# ui/code_statistics_config_window.py
class CodeStatisticsConfigWindow:
    """代码统计配置窗口"""
    def show_config_dialog(self):
        """显示配置对话框"""
        ...
    
    def get_config(self) -> Dict:
        """获取配置"""
        ...

# services/code_statistics_service.py
class CodeStatisticsService:
    """代码统计业务逻辑服务"""
    def __init__(self, code_counter: CodeCounterBase):
        self.code_counter = code_counter
    
    def execute_statistics(self, config: Dict) -> StatisticsResult:
        """执行统计"""
        ...
    
    def format_report(self, result: StatisticsResult) -> str:
        """格式化报告"""
        ...

# services/report_formatter.py
class ReportFormatter:
    """报告格式化器"""
    def format_text(self, result: StatisticsResult) -> str:
        """格式化文本报告"""
        ...
    
    def format_markdown(self, result: StatisticsResult) -> str:
        """格式化Markdown报告"""
        ...

# services/result_exporter.py
class ResultExporter:
    """结果导出器"""
    def __init__(self):
        self.exporters: Dict[str, Exporter] = {
            'csv': CSVExporter(),
            'json': JSONExporter(),
            'xlsx': XLSXExporter(),
        }
    
    def register_exporter(self, format_name: str, exporter: Exporter):
        """注册新的导出器"""
        self.exporters[format_name] = exporter
    
    def export(self, result: StatisticsResult, format_name: str, path: str):
        """导出结果"""
        exporter = self.exporters.get(format_name)
        if exporter:
            exporter.export(result, path)

# ui/code_statistics_ui.py（简化后）
class CodeStatisticsUI:
    """代码统计UI协调器"""
    def __init__(self, ...):
        self.config_window = CodeStatisticsConfigWindow(...)
        self.statistics_service = CodeStatisticsService(...)
        self.result_exporter = ResultExporter()
        self.chart_renderer = ChartRenderer(...)
    
    def show_config_dialog(self):
        """显示配置对话框"""
        self.config_window.show_config_dialog()
    
    def start_statistics(self, config: Dict):
        """启动统计"""
        result = self.statistics_service.execute_statistics(config)
        # 显示结果、导出、显示图表等
        ...
```

**优点**：
- 每个类职责单一
- 易于测试和维护
- 符合单一职责原则

### 3.3 引入抽象接口

#### 方案：定义统计服务接口

```python
# services/code_counter_interface.py
from abc import ABC, abstractmethod

class ICodeCounter(ABC):
    """代码统计服务接口"""
    
    @abstractmethod
    def count_code_lines(self, path: str, ...) -> str:
        """统计代码行数"""
        pass
    
    @abstractmethod
    def count_code_by_language(self, path: str, ...) -> Dict:
        """按语言统计代码量"""
        pass

# services/advanced_code_counter.py
class AdvancedCodeCounter(CodeCounterBase, ICodeCounter):
    """增强代码统计服务"""
    ...

# ui/code_statistics_ui.py
class CodeStatisticsUI:
    def __init__(self, code_counter: ICodeCounter, ...):
        self.code_counter = code_counter  # 依赖接口而非具体实现
        ...
```

**优点**：
- 降低耦合度
- 易于替换实现
- 符合依赖倒置原则

### 3.4 使用策略模式扩展导出功能

#### 方案：导出器策略模式

```python
# services/exporters/base_exporter.py
from abc import ABC, abstractmethod

class Exporter(ABC):
    """导出器抽象基类"""
    
    @abstractmethod
    def export(self, result: StatisticsResult, path: str) -> None:
        """导出结果"""
        pass
    
    @abstractmethod
    def get_file_extension(self) -> str:
        """获取文件扩展名"""
        pass

# services/exporters/csv_exporter.py
class CSVExporter(Exporter):
    def export(self, result: StatisticsResult, path: str) -> None:
        """导出为CSV"""
        ...
    
    def get_file_extension(self) -> str:
        return "csv"

# services/exporters/json_exporter.py
class JSONExporter(Exporter):
    def export(self, result: StatisticsResult, path: str) -> None:
        """导出为JSON"""
        ...
    
    def get_file_extension(self) -> str:
        return "json"

# services/exporters/xlsx_exporter.py
class XLSXExporter(Exporter):
    def export(self, result: StatisticsResult, path: str) -> None:
        """导出为XLSX"""
        ...
    
    def get_file_extension(self) -> str:
        return "xlsx"
```

**优点**：
- 易于添加新导出格式
- 符合开闭原则
- 每个导出器独立测试

### 3.5 统一数据模型

#### 方案：使用 dataclass 统一数据模型

```python
# models/code_statistics.py
from dataclasses import dataclass
from typing import List, Dict, Optional

@dataclass
class FileStat:
    """文件统计类"""
    path: str
    total: int = 0
    code: int = 0
    comment: int = 0
    blank: int = 0
    
    def add_line(self, kind: str) -> None:
        ...

@dataclass
class Summary:
    """统计汇总类"""
    files: int = 0
    total: int = 0
    code: int = 0
    comment: int = 0
    blank: int = 0
    
    def add(self, stat: FileStat) -> None:
        ...

@dataclass
class FunctionStat:
    """函数统计类"""
    name: str
    file_path: str
    line_count: int
    start_line: int
    end_line: int

@dataclass
class StatisticsResult:
    """统计结果数据模型"""
    summary: Summary
    by_language: Dict[str, Summary]
    by_ext: Dict[str, Summary]
    per_file: List[FileStat]
    elapsed_time: float
    python_function_stats: Optional[PythonFunctionStats] = None
    c_function_stats: Optional[CFunctionStats] = None
```

**优点**：
- 数据模型统一
- 类型安全
- 易于序列化

## 四、重构优先级

### 高优先级（立即重构）
1. **消除代码重复**：提取 `CodeCounterBase`，消除两个Counter类的重复代码
2. **拆分职责**：将 `CodeStatisticsUI` 拆分为多个类

### 中优先级（近期重构）
3. **引入抽象接口**：定义 `ICodeCounter` 接口
4. **统一数据模型**：使用 dataclass 统一数据模型

### 低优先级（可选优化）
5. **导出器策略模式**：如果未来需要添加更多导出格式，再重构

## 五、重构后的架构

```
services/
├── code_counter_base.py      # 公共基类
├── code_counter.py           # 基础统计服务（继承基类）
├── advanced_code_counter.py  # 增强统计服务（继承基类）
├── code_statistics_service.py # 统计业务逻辑服务
├── report_formatter.py        # 报告格式化器
└── exporters/
    ├── base_exporter.py      # 导出器基类
    ├── csv_exporter.py       # CSV导出器
    ├── json_exporter.py      # JSON导出器
    └── xlsx_exporter.py      # XLSX导出器

models/
└── code_statistics.py        # 统一数据模型

ui/
├── code_statistics_config_window.py  # 配置窗口
├── code_statistics_ui.py             # UI协调器（简化）
├── chart_types.py                     # 图表类型（已良好）
├── chart_layout.py                    # 布局策略（已良好）
├── chart_data_extractor.py            # 数据提取器（已良好）
└── chart_renderer.py                  # 图表渲染器（已良好）
```

## 六、可视化模块评价

### 优点（已符合设计原则）
1. ✅ **图表类型使用策略模式**：`ChartType` 抽象基类，易于扩展新图表类型
2. ✅ **布局策略使用策略模式**：`LayoutStrategy` 抽象基类，易于扩展新布局
3. ✅ **样式配置分离**：`ChartStyle` 数据类，易于自定义样式
4. ✅ **数据提取器分离**：`ChartDataExtractor` 独立类，职责清晰
5. ✅ **符合开闭原则**：添加新图表类型或布局无需修改现有代码

### 可优化点（可选）
1. **图表注册机制**：可以考虑使用插件机制，动态加载图表类型
2. **样式主题**：可以支持多个预设主题（如暗色主题、亮色主题）
3. **数据验证**：在 `ChartDataExtractor` 中添加更严格的数据验证

## 七、总结

### 需要重构的模块
1. **代码统计模块**：存在代码重复、职责不清、耦合度高的问题
2. **UI层**：`CodeStatisticsUI` 类过大，职责过多

### 已符合设计原则的模块
1. **可视化模块**：已良好地使用了策略模式、开闭原则等设计原则

### 重构收益
- **可维护性**：代码更清晰，职责更明确
- **可扩展性**：易于添加新功能（新导出格式、新统计功能）
- **可测试性**：每个类职责单一，易于单元测试
- **代码质量**：消除重复代码，提高代码复用率

